<!DOCTYPE html
    PUBLIC '-//W3C//DTD XHTML 1.0 Transitional//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Computer Graphics - PA4</title>

    <link href="resources/bootstrap.min.css" rel="stylesheet">
    <link href="resources/offcanvas.css" rel="stylesheet">
    <link href="resources/custom2014.css" rel="stylesheet">
    <link href="resources/twentytwenty.css" rel="stylesheet" type="text/css" />
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<body>

    <div class="container headerBar">
        <h1>Programming Assignment 4 - Fran√ßois Costa (19-931-989)</h1>
    </div>

    <div class="container contentWrapper">
        <div class="pageContent">

            <!-- ================================================================= -->

            <h2>Part 1: Dielectric BSDF</h2>

            <p> We had to implement an idea dieletric brdf. The implementation was not that hard. The first step is to
                check if the ray is going to be reflected or refracted. How can we do this? The answer is the fresnel
                equations.

                In the case the ray is reflected, we return the reflection of the ray. In the case the ray is refracted,
                we can compute the new vector using the Snell's equations. Of course for both cases, we need to fill the
                data structure BSDFQueryRecord.
            </p>

            <!-- ================================================================= -->

            <h2>Part 2: Path Tracing</h2>

            <p>For this part of the assignement, I created two new files, namely path_mats.cpp & path_mis.cpp </p>

            <h3>path_mats Implementation</h3>

            <p>The pats_mats integrator is very similar to the direct_mats one. The only difference is that we project
                the ray until the russian roulette says stop. In the direct one, we trace the ray and project only a
                second ray and then we stop. The tricky part of the implementation is that we need to create a Color3f
                data structure with some attenuation.

                The function works as follow. <br /><br />
                while [TRUE]
            <ul>
                <li>trace a ray</li>
                <li>check if we intersect a mesh</li>
                <li>add Le if the intersected mesh is an emitter</li>
                <li>update russian roulette -> stop if roulette says stop</li>
                <li>sample the BDRF</li>
                <li>trace a new ray</li>
            </ul>
            </p>

            <h3>path_mis</h3>

            <p>This integrator was harder for me to implement. The general idea is similar to the direct_mis one. The
                difference is that we want to trace the ray recursively and stop when the russian roulette takes the
                decision to stop. The integrator first sample a light source. Then perform russian roulette and then
                samples the brdf. Of course we always need to ajust the weights w_ems and w_mats. This is
                straightforward with the available data structures in nori.

                The function works as follow. <br /><br />
                while [TRUE]
            <ul>
                <li>trace a ray</li>
                <li>add Le if the intersected mesh is an emitter</li>
                <li>sample ems part</li>
                <li>update russian roulette -> stop if roulette says stop</li>
                <li>sample mats part</li>
                <li>check if the ray intersect a surface</li>
                <li>trace a new ray</li>
            </ul>

            </p>

            <h3>Validation</h3>

            <p></p>

            <img src="images/test1.png" alt="Test results" />
            <img src="images/test2.png" alt="Test results" />

            <p>Cornell box scene</p>

            <div class="twentytwenty-container">
                <img src="images/cbox_path_mats.png" alt="Mats" class="img-responsive">
                <img src="images/cbox_path_mis.png" alt="Mis" class="img-responsive">
                <img src="images/cbox_path_mis_512spp.png" alt="Reference" class="img-responsive">
            </div> <br>

            <p>Table scene</p>

            <div class="twentytwenty-container">
                <img src="images/table_path_mats.png" alt="Mats" class="img-responsive">
                <img src="images/table_path_mis.png" alt="Mis" class="img-responsive">
                <img src="images/table_path_mis_512spp.png" alt="Reference" class="img-responsive">
            </div> <br>

            <!-- ================================================================= -->

            <h2>Part 3: Photon Mapping</h2>

            <p>For this part of the assignment, I extended arealight.cpp & photonmapper.cpp/p>

            <h3>Implementation</h3>

            <p>The first function I extended is samplePhoton. First we sample the surface. Then we sample a ray from the
                surface and we evaluate the point. This function was straightforward.</p>

            <p>The next function is the function preprocess. It is important to distinguish the number of emitted
                photons and m_photonCount. My implementation works as follow. For each emitted photon, we choose a
                randomEmitter and start tracing from this emitter. We trace the photon until the russian roulette says
                stop. The tracing process is not very complicated. The first step is to check if we intersects
                something. If the intersected mesh has a diffuse BSDF, we can store the photon. We choose the next
                ray by sampling the BRDF.</p>

            <p>The last function is the LI function. We create a ray and trace it recursively until we don't get any
                intersection, the russian roulette says stop or the BRDF is a diffuse surface. When we intersect a
                diffuse surface, we search the photons, add the value of each photons and then return the
                result using the equation. If we intersect an emitter, of course we add the radiance to the final
                result. At the end, the process is very similar to the mats integrator. </p>

            <h3>Validation</h3>

            <p>Cornell box scene</p>

            <div class="twentytwenty-container">
                <img src="images/cbox_pmap_32spp_10Mp.png" alt="Reference" class="img-responsive">
                <img src="images/cbox_pmap.png" alt="Mine" class="img-responsive">
            </div> <br>

            <p>Table scene</p>

            <div class="twentytwenty-container">
                <img src="images/table_pmap_256spp_5Mp.png" alt="Reference" class="img-responsive">
                <img src="images/table_pmap.png" alt="Mine" class="img-responsive">
            </div> <br>

            <p>Clocks scene</p>

            <div class="twentytwenty-container">
                <img src="images/clocks_64spp_10Mp.png" alt="Reference" class="img-responsive">
                <img src="images/clocks.png" alt="Mine" class="img-responsive">
            </div> <br>
        </div>
    </div>


    <!-- Bootstrap core JavaScript -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="resources/bootstrap.min.js"></script>
    <script src="resources/jquery.event.move.js"></script>
    <script src="resources/jquery.twentytwenty.js"></script>


    <script>
        $(window).load(function () { $(".twentytwenty-container").twentytwenty({ default_offset_pct: 0.5 }); });
    </script>

</body>

</html>